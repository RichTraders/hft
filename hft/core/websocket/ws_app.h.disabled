/*
 * MIT License
 *
 * Copyright (c) 2025 NewOro Corporation
 *
 * Permission is hereby granted, free of charge, to use, copy, modify, and distribute
 * this software for any purpose with or without fee, provided that the above
 * copyright notice appears in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND.
 */

#ifndef WEBSOCKET_APP_H
#define WEBSOCKET_APP_H

#include <common/spsc_queue.h>
#include <common/thread.hpp>
#include "logger.h"

#include "ws_transport.h"

constexpr int kWsQueueSize = 64;
constexpr int kWsReadBufferSize = 1024;
constexpr int kWsWriteThreadSleep = 100;

namespace FIX8 {
class Message;
}

namespace core {

template <typename Derived, FixedString ReadThreadName,
    FixedString WriteThreadName>
class WebsocketApp {
 public:
  WebsocketApp(const std::string& address, int port, std::string path,
      bool use_ssl, std::string sender_comp_id, std::string target_comp_id,
      common::Logger* logger);

  ~WebsocketApp();

  using MsgType = std::string;
  using SendId = std::string;
  using TargetId = std::string;
  using RequestId = std::string;
  using MarketDepthLevel = std::string;
  using SymbolId = std::string;

  bool start();

  void stop();
  void prepare_stop_after_logout() noexcept;
  void wait_logout_and_halt_io() noexcept;
  void note_logout_ack() noexcept;

  bool send(const std::string& msg) const;

  void write_loop();
  void read_loop();

  void register_callback(const MsgType& type,
      const std::function<void(FIX8::Message*)>& callback);

  [[nodiscard]] std::string create_log_on(const std::string& sig_b64,
      const std::string& timestamp);
  [[nodiscard]] std::string create_log_out();

  std::string create_heartbeat(FIX8::Message* message);
  void encode(std::string& data, FIX8::Message* msg) const;

  std::string timestamp();

 private:
  static bool strip_to_header(std::string& buffer);
  std::string get_signature_base64(const std::string& timestamp) const;
  static bool peek_full_message_len(const std::string& buffer, size_t& msg_len);
  static bool extract_next_message(std::string& buffer, std::string& msg);

  void process_message(const std::string& raw_msg);

  common::Logger::Producer logger_;
  WebSocketTransport transport_;
  std::map<std::string, std::function<void(FIX8::Message*)>> callbacks_;
  std::unique_ptr<common::SPSCQueue<std::string, kWsQueueSize>> queue_;

  common::Thread<WriteThreadName> write_thread_;
  common::Thread<ReadThreadName> read_thread_;
  std::atomic<bool> thread_running_{false};

  bool log_on_{false};
  const std::string sender_id_;
  const std::string target_id_;

  std::atomic<bool> logout_ack_{false};
  std::mutex stop_mtx_;
  std::condition_variable stop_cv_;
  static constexpr auto kWsLogoutWait = std::chrono::milliseconds(5000);
};

}  // namespace core

#endif